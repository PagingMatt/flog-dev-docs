<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Logger (monoidl.Monoidl__Logger.Logger)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">monoidl</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Monoidl__Logger.Logger</span></h1></header><div class="doc"><p>Logger functor wraps around some message consumer. Therefore it is the
responsibility of the consumer to actually handle the messages. The concern
of the Logger is purely to arrange computations within the logging monad.</p></div><h3 class="heading">Parameters</h3><div><div class="spec argument" id="argument-1-C"><a href="#argument-1-C" class="anchor"></a><div class="def argument"><code><a href="argument-1-C/index.html">C</a> : <a href="../../Monoidl/Consumer/index.html#module-type-Consumer">Monoidl.Consumer.Consumer</a></code></div><div class="doc"></div></div></div><h3 class="heading">Signature</h3><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code></code><code></code></div><div class="doc"><p>Logger type.</p></div></div><div class="spec val" id="val-return"><a href="#val-return" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>return : <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Lift a value up into the logging monad.</p></div></div><div class="spec val" id="val-(=&gt;=)"><a href="#val-(=&gt;=)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(=&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Taking a value already lifted into the logging monad, apply a function to
the value and then lift the result into the monad. This performs no
logging action and purely drives computation along.</p></div></div><div class="spec val" id="val-(=&gt;|)"><a href="#val-(=&gt;|)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(=&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Taking a value already lifted into the logging monad and a function which
does some other logging, apply the function to the value and then relying
on the monoidal properties on the underlying message consumers combine
the current state of the log (wrapped around the initial value) with the
log state produced by the function.</p></div></div><div class="spec val" id="val-(==|)"><a href="#val-(==|)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(==|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../../Monoidl/Message/Message/index.html#type-t">Monoidl.Message.Message.t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Taking a value already lifted into the logging monad and a message to
pass down the logging consumer, handle the message and pass along the log
state.</p></div></div></body></html>