<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ConsumerLogger (flog.Flog.Logger.ConsumerLogger)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">flog</a> &#x00BB; <a href="../../index.html">Flog</a> &#x00BB; <a href="../index.html">Logger</a> &#x00BB; ConsumerLogger</nav><h1>Module <code>Logger.ConsumerLogger</code></h1><p>Logger functor wraps around some message consumer. Therefore it is the responsibility of the consumer to actually handle the messages. The concern of the Logger is purely to arrange computations within the logging monad.</p></header><h3 class="heading">Parameters</h3><dl><code><a href="argument-1-C/index.html">C</a> : <a href="../../Consumers/index.html#module-type-Consumer">Consumers.Consumer</a></code></dl><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>'a t</code></dt><dd><p>Logger type which wraps around some value.</p></dd></dl><dl><dt class="spec value" id="val-start"><a href="#val-start" class="anchor"></a><code><span class="keyword">val </span>start : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Opens a region that can be logged by lifting a value up into the logging monad provided by flog.</p></dd></dl><dl><dt class="spec value" id="val-(=&gt;=)"><a href="#val-(=&gt;=)" class="anchor"></a><code><span class="keyword">val </span>(=&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Taking a value already lifted into the logging monad, apply a function to the value and then lift the result into the monad. This performs no logging action and purely drives computation along.</p></dd></dl><dl><dt class="spec value" id="val-(=&gt;|)"><a href="#val-(=&gt;|)" class="anchor"></a><code><span class="keyword">val </span>(=&gt;|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Taking a value already lifted into the logging monad and a function which does some other logging, apply the function to the value and then relying on the monoidal properties on the underlying message consumers combine the current state of the log (wrapped around the initial value) with the log state produced by the function.</p></dd></dl><dl><dt class="spec value" id="val-(==|)"><a href="#val-(==|)" class="anchor"></a><code><span class="keyword">val </span>(==|) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../Message/index.html#type-t">Message.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Taking a value already lifted into the logging monad and a message to pass down the logging consumer, handle the message and pass along the log state.</p><p>'Pass-through' logging.</p></dd></dl><dl><dt class="spec value" id="val-(=|=)"><a href="#val-(=|=)" class="anchor"></a><code><span class="keyword">val </span>(=|=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../../Message/index.html#type-t">Message.t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Taking a value already lifted into the logging monad and a function to construct a message from the wrapped value, apply the function to build a message, pass the message to the underlying consumer and pass along the log state.</p><p>'Pass-in' logging.</p></dd></dl><dl><dt class="spec value" id="val-stop"><a href="#val-stop" class="anchor"></a><code><span class="keyword">val </span>stop : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span><span class="keyword"> * </span><a href="../../Message/index.html#type-t">Message.t</a> list option</code></dt><dd><p>When the region that needs to be logged is exited the log can be closed. The result of this is the value currently wrapped in the monad and the value of calling flush on the Consumer module that this functor was applied to possibly a collection of messages should state be maintained by the consumer.</p></dd></dl></div></body></html>